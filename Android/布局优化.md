## 渲染基本知识
Android系统每隔16ms就重新绘制一次Activity，也就是说，我们的应用必须在16ms内完成屏幕刷新的全部逻辑操作，即每一帧只能停留16ms。   
渲染操作通常依赖于两个核心组件：CPU与GPU：
* 在CPU方面，最常见的性能问题是不必要的布局和失效
* 在GPU方面，最常见的问题是我们所说的过度绘制（overdraw）

### 过度绘制
Overdraw(过度绘制)描述的是屏幕上的某个像素在同一帧的时间内被绘制了多次。在多层次的UI结构里面， 如果不可见的UI也在做绘制的操作，这就会导致某些像素区域被绘制了多次。这就浪费大量的CPU以及GPU资源。  

开启过度绘制检测：设置 -> 开发者选项 -> 调试GPU过度绘制 -> 显示GPU过度绘制  

![过渡绘制](http://upload-images.jianshu.io/upload_images/1836169-56ffcb4175ebe337.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* 蓝色： 意味着overdraw 1倍。像素绘制了两次。大片的蓝色还是可以接受的（若整个窗口是蓝色的，可以摆脱一层）。
* 绿色： 意味着overdraw 2倍。像素绘制了三次。中等大小的绿色区域是可以接受的但你应该尝试优化、减少它们。
* 淡红： 意味着overdraw 3倍。像素绘制了四次，小范围可以接受。
* 深红： 意味着overdraw 4倍。像素绘制了五次或者更多。这是错误的，要修复它们。

## 如何避免过度绘制  
### 去掉window的默认背景
我们的Activity使用的Theme可能会默认的加上背景色，不需要的情况下可以去掉。
```xml
<style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">    
    <item name="windowBackground">null</item>
</style>
```  
或者在Activity中进行设置
```java
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    getWindow().setBackgroundDrawable(null);
}
```
### 避免背景色的重复设置
有时候在根布局中设置了背景颜色之后，单独的View，比如TextView就可以不用再设置背景颜色了。  
这个主要是结合UI设置，在写布局文件的时候稍加注意就可以避免的

### clipRect的使用
我们可以通过canvas.clipRect()来 帮助系统识别那些可见的区域。这个方法可以指定一块矩形区域，只有在这个区域内才会被绘制，其他的区域会被忽视。

### 减少嵌套层次及控件个数
通过Hierarchy Viewer这个方便可视化的工具，可以得到：树形结构总览、布局view、每一个View（包含子View）绘制所花费的时间及View总个数。  
备注： Hierarchy Viewer不能连接真机的问题可以通过ViewServer这个库解决；  

Android的布局文件的加载是LayoutInflater利用pull解析方式来解析，然后根据节点名通过反射的方式创建出View对象实例；  

### Merge

### ViewStub  
ViewStub称之为“延迟化加载”


## [Android中RelativeLayout和LinearLayout性能分析](http://www.jianshu.com/p/8a7d059da746#)


## 相关链接
[Android 性能优化（二）之布局优化面面观](https://gold.xitu.io/post/58a442b661ff4b006c8a63f5)  
[Android性能优化第（十）篇---布局优化](http://www.jianshu.com/p/c0e0cca14162)
